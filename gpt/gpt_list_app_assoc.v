(**
ChatGPTにCoqのコードを書かせてみた（その2）
==============================
2023/05/20


@suharahiromichi


ChatGPTにCoqのコードを書かせてみました。

ソフトウェアの基礎 ``https://proofcafe.org/sf/Lists_J.html``
にある非形式的な証明を与えて、そこから形式的な証明をつくるように指示しました。

その結果が、「Coqを使って、上記の定理を形式化した証明を以下に示します。」から、
「この証明を実行すると、Coqが定理を証明し、証明が完了するはずです。」までです。

Coqのコードは修正不要で正しいもので、テキストの例とほぼ同じものでした。
また、コード中のコメントは、ChatGPTの生成したコードに最初から含まれていました。
*)

(**
# 質問

「

定理証明支援系Coqを使って、以下の定理の証明を形式化してください。

定理: 任意のリスト l1、 l2、 l3 について、 (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3) が成り立つ。

証明: l1 についての帰納法で証明する
まず、 l1 = [] と仮定して
       ([] ++ l2) ++ l3 = [] ++ (l2 ++ l3)

を示す。これは ++ の定義から自明である。

次に l1 = n::l1' かつ
       (l1' ++ l2) ++ l3 = l1' ++ (l2 ++ l3)

（帰納法の仮定）と仮定して
       ((n :: l1') ++ l2) ++ l3 = (n :: l1') ++ (l2 ++ l3)

を示す。 ++ の定義から、この式は以下のように変形できる。
       n :: ((l1' ++ l2) ++ l3) = n :: (l1' ++ (l2 ++ l3))

これは帰納法の仮定から直接導かれる。 ☐

」
*)

(**
# 回答

「

Coqを使って、上記の定理を形式化した証明を以下に示します。
 *)

Require Import Coq.Lists.List.

Theorem append_assoc : forall (l1 l2 l3 : list nat),
  (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).
Proof.
  intros l1 l2 l3.
  induction l1 as [| n l1' IH].
  - (* l1 = [] *)
    simpl. reflexivity.
  - (* l1 = n::l1' *)
    simpl.
    rewrite IH.
    reflexivity.
Qed.

(**
この証明では、Coqのタクティクを使用して帰納法を適用しています。
最初にintrosタクティクを使用して、リストl1、l2、l3を仮定します。
次に、inductionタクティクを使用して、リストl1についての帰納法を開始します。2つのサブゴールが生成されます。

最初のサブゴールでは、l1が空リスト[]の場合を扱っています。
この場合、simplタクティクを使用して式を簡約し、reflexivityタクティクを使用して両辺が等しいことを示します。

2番目のサブゴールでは、l1がn::l1'の形をしている場合を扱っています。simplタクティクを使用して
式を簡約し、rewriteタクティクを使用して帰納法の仮定IHを適用します。
最後に、reflexivityタクティクを使用して両辺が等しいことを示します。

この証明を実行すると、Coqが定理を証明し、証明が完了するはずです。

」
 *)

(* END *)
